package service;


import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.ietf.jgss.GSSContext;
import org.ietf.jgss.GSSException;
import org.ietf.jgss.GSSManager;
import org.ietf.jgss.MessageProp;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Kryword
 */
public class JGSSSecureAssociation {

    final GSSContext context;
    DataOutputStream dos;
    DataInputStream dis;
    
    public JGSSSecureAssociation(GSSContext context) {
        this.context = context;
    }
    
    
    public GSSContext init(final InputStream is,
                final OutputStream os,
                final boolean mutualAuthentication,
                final boolean confienciality){
        try{
            final DataOutputStream dos = new DataOutputStream(os);
            final DataInputStream dis = new DataInputStream(is);
            // Do the context eastablishment loop
            for (byte[] inToken = new byte[0]; !context.isEstablished();) {

              // inToken is ignored on the first call
              final byte[] outToken = context.initSecContext(inToken, 0, inToken.length);

              // Send a token to the server if one was generated by initSecContext
              if (outToken != null) {
                System.out.println("  * Will send token of size "
                        + outToken.length
                        + " from initSecContext.");
                dos.writeInt(outToken.length);
                dos.write(outToken);
                dos.flush();
              }

              // If the client is done with context establishment
              // then there will be no more tokens to read in this loop
              if (!context.isEstablished()) {
                inToken = new byte[dis.readInt()];
                System.out.println("  * Will read input token of size "
                        + inToken.length
                        + " for processing by initSecContext");
                dis.readFully(inToken);
              }
            }
        }catch(GSSException|IOException e){
            
        }
        return context;
    }
    public GSSContext accept(final InputStream is,
            final OutputStream os){
        this.dos = new DataOutputStream(os);
        this.dis = new DataInputStream(is);
        // Do the context establishment loop
        try{
            while (!context.isEstablished()) {
              final byte[] inToken = new byte[dis.readInt()];
              System.out.println("  * Will read input token of size "
                      + inToken.length
                      + " for processing by acceptSecContext");

              dis.readFully(inToken);
              final byte[] outToken = context.acceptSecContext(inToken, 0, inToken.length);

              // Send a token to the peer if one was generated by acceptSecContext
              if (outToken != null) {

                System.out.println("  * Will send token of size "
                        + outToken.length
                        + " from acceptSecContext.");
                dos.writeInt(outToken.length);
                dos.write(outToken);
                dos.flush();
              }
            }
        }catch(GSSException|IOException e){
            
        }
        return context;
    }
    
    public boolean send(final String message, final boolean confidenciality){
        try {
            final byte[] messageBytes = message.getBytes();
            final MessageProp prop = new MessageProp(0, true);
            
            byte[] token;
            token = context.wrap(messageBytes, 0, messageBytes.length, prop);
            System.out.println("  * Will send wrap token of size " + token.length);
            dos.writeInt(token.length);
            dos.write(token);
            dos.flush();
            
            token = new byte[dis.readInt()];
            System.out.println("  * Will read token of size " + token.length);
            dis.readFully(token);
            context.verifyMIC(token, 0, token.length,
                messageBytes, 0, messageBytes.length,
                prop);
            return true;
        } catch (GSSException ex) {
            Logger.getLogger(JGSSSecureAssociation.class.getName()).log(Level.SEVERE, null, ex);
            return false;
        } catch (IOException ex) {
            Logger.getLogger(JGSSSecureAssociation.class.getName()).log(Level.SEVERE, null, ex);
            return false;
        }
    }
    
    public String receive(){
        final String str;
        try {
            final MessageProp prop = new MessageProp(0, false);
            /* 
            * Read the token.
            */
           byte[] token = new byte[dis.readInt()];
           System.out.println("  * Will read token of size " + token.length);
           dis.readFully(token);
           /* 
            * Unwrap transmited data.
            */
            final byte[] bytes = context.unwrap(token, 0, token.length, prop);
            str = new String(bytes);
            prop.setQOP(0);

            token = context.getMIC(bytes, 0, bytes.length, prop);

            System.out.println("  * Will send MIC token of size "
                    + token.length);
            dos.writeInt(token.length);
            dos.write(token);
            dos.flush();
            context.dispose();
        } catch (GSSException|IOException e) {
            return null;
        }
        return str;
    }
}
